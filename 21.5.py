证明：若p≡1（mod 5），则5是p的二次剩余。

令P=（p-1）/2
（1,2,3, ...（p-1）/2 ）* 5^(p-1)/2 = （5,10,15, ...5（p-1）/2 ）
5^(p-1)/2 *P! = （5,10,15, ...5（p-1）/2 ）

设p=5x+1,因为p是奇数，so：x是偶数，so：P是整数
现在要证明右边 => P! * (-1)^n, 证明这个n为偶数，然后就有
5^(p-1)/2 *P! = P! * (-1)^n
两边消去P!
5^(p-1)/2  = (-1)^n(mod p) => 
5^(p-1)/2  = 1 (mod p)
根据殴拉准则：
a^(p-1)/2≡(a/p)(mod p)[注意:此处的(a/p)是勒让德符号，不是除法]，有 =>
(5/p)=1, so:5是p的二次剩余。
现在的问题是证明n是偶数。
考虑（5,10,15, ...5（p-1）/2 ）中大于（p-1）/2的数的个数
5（p-1）/2 - （p-1）/2 = 2（p-1）= 2(5x+1-1)= 10x
数列中项数是5,所以大于（p-1）/2的数的个数一共有（10x/5）=2x个,把这些数分成几块，
（p-1）/2... 2(p-1)/2...3（p-1）/2...4（p-1）/2... 5（p-1）/2
为了便于叙述，依次标为1块,2块,3块,4块。注意（p-1）/2不在2x个数之内。很显然，每块中的个数相同。
1块中的数模p，都是负数（因为要小于（p-1）/2），2块中的数，都是正数，3块负数，4块正数。1块和3块中的数相等。
所以n是偶数。原题得证。
若p≡2（mod 5）再把大于（p-1）/2的数分成4块：
（p-1）/2... 2(p-1)/2...3（p-1）/2...4（p-1）/2... 5（p-1）/2，情况是一样的，1块中的数模p，都是负数（因为要小于（p-1）/2），2块中的数，都是正数，3块负数，4块正数。对比一下1块和3块。1块中的数从（p-1)/2到2(p-1)/2，不包括（p-1)/2但是包括2(p-1)/2。3块中的数从3（p-1)/2到4(p-1)/2，不包括3（p-1)/2但是包括4(p-1)/2。
3（p-1)/2≡（p-1)/2 -1（mod p）
3（p-1)/2 + 1= 3（5x+2-1）/2 =3（5x+1）/2 + （5x+1）-（5x+1） +1=
5（5x+1）/2 -5x≡0（mod 5）
3（p-1)/2 + 1≡（p-1)/2 -1 +1（mod p）≡（p-1)/2 （mod p）
所以第3块的第一个不是负数，而是（p-1)/2 。


         [(p-1)/2... 2(p-1)/2...3(p-1)/2...4(p-1)/2... 5(p-1)/2]
mod(p) = [  P    ...    -1   ...  P-1   ...  -2    ...   P-2   ]
mod(5) = [  0    ...    0    ...  0     ...  0     ...   0     ](5*x+1)
mod(5) = [  -2   ...    1    ...  -1    ...  2     ...   0     ](5*x+2)
mod(5) = [  -4   ...    2    ...  -2    ...  4     ...   0     ](5*x+3)
mod(5) = [  -1   ...    3    ...  -3    ...  1     ...   0     ](5*x+4)

var P =100
var pp = [P, -1, P-1, -2, P-2]
var x1 = [0, 0, 0, 0, 0]
var x2 = [-2, 1, -1, 2, 0]
var x3 = [-4, 2, -2, 4, 0]
var x4 = [-1, 3, -3, 1, 0]

var vari = [x1, x2, x3, x4]

for (var i = 0; i < vari.length; i++) {
    var bb3
    var bt3
    if(pp[2] - vari[i][2] <= P) {bb3 = 3*P- vari[i][2] +5; }
    else{bb3 = 3*P- vari[i][2]}
    if(pp[0] - vari[i][0] <= P) {bb1 = P - vari[i][0] +5; }
    else{bb1 = P - vari[i][0]}
    if(-(pp[3] - vari[i][3]) > 5) {bt3 = 4*P-vari[i][3] +5}
    else{bt3 = 4*P-vari[i][3]}
    var block1 = [bb1, 2*P-vari[i][1]]
    var block3 = [bb3, bt3]
    if (block3[1]-block3[0] === block1[1]-block1[0]) console.log(vari[i])
}







var st4 = [-1, -2, -3, 1, 0]
var 1t = [P+1, 2*P-3]
var 3t = [3*P+3, 4*P-1]
var 1g = 2*P-3-P-1 = P-4
var 3g = 4*P-1-3*P-3 =P-4

var st3 = [1, 2, 3, 4, 0]
var 1t = [P+4, 2*P-2]
var 3t = [3*P+2, 4*P+1]
var 1g = 2*P-2-P-4 = P-6
var 3g = 4*P+1-3*P-2 =P-1


var P
var st2 = [-2, 1, -1, 2, 0]
var 1t = [P+2, 2*P-1]
var 3t = [3*P+6, 4*P-2]
var 1g = 2*P-1-P-2 = P-3
var 3g = 4*P-2-3*P-6 =P-8


var st1 = [0, 0, 0, 0, 0]
var 1t = [P+5, 2*P]
var 3t = [3*P+5, 4*P]
var 1g = 2*P-P-5 = P-5
var 3g = 4*P-3*P-5 =P-5






